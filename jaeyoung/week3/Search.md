# 검색 알고리즘
## 선형 검색
가장 기본적인 검색 방법으로, 맨 앞에서 부터 순차적으로 검색한다.   
가령, 다음과 같은 배열이 있다.   

| 0 | 1 | 2 | 3 | 4 | 5 |   
| :-: | :-: | :-: | :-: | :-: | :-: |   
| 3 | 7 | -1 | 4 | 11 | 0 |   

찾고 싶은 수가 4라고 하면, 왼쪽부터 4가 있는지 하나씩 다 살펴본다.   

맨 처음 3은 4와 같지 않으므로 다음 수인 7, 그 다음 수인 -1을 비교하다가 4를 찾으면 탐색이 종료 된다.   

선형 탐색은 탐색 알고리즘의 가장 기초가 되는 알고리즘으로 구현하기 매우 쉽다는 장점이 있지만,   
반대로 배열의 크기가 커질수록 **찾는 시간이 오래 걸린다** 는 단점이 있다.    

최악의 경우 마지막 요소까지 탐색하므로 **O(N)** 의 시간 복잡도를 갖는다.   
코드는 다음과 같다.

```java
public class Main {
    public static void main(String[] args) {
        int[] arr = {3, 7, -1, 4, 11, 0};
        int x = 4;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == x) {
                System.out.println("x in arr[" + i + "]");
                return;
            }
        }
        System.out.println("x not found");
    }
}
```

## 이진탐색
이진탐색(Binary Search)는 **오름차순으로 정렬** 된 리스트에서 특정한 값의 위치를 찾는 알고리즘이다.   

처음 중간의 값을 임의의 값으로 선택하여, 찾고자 하는 값과 대소 비교를 통해 범위를 좁힌다.   

처음 선택한 중앙값이 찾는 값보다 크면 그 값은 최댓값이 되며, 작으면 최솟값이 된다.   

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |   
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |   
| -8 | -3 | 2 | 0 | 5 | 8 | 11 | 15 |   

위와 같이 크기가 8인 배열, 찾는 값은 -8이라고 가정을 한다.   
먼저, 중앙값을 고른다. (0 + 7) / 2 = 3.5 이므로 3번째 인덱스의 값 0이 중앙값이 된다.   

찾는 값은 -8이므로 중앙값 0보다 작다.   
따라서, 중앙값 이상의 값은 필요가 없고, 배열 내 최댓값은 2가 된다.   

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |   
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |   
| **-8** | **-3** | **2** | 0 | 5 | 8 | 11 | 15 |

이제 남아 있는 [0, 2] 구간 중에서 중앙값을 고르고 찾는 값과 동일한지 비교한다.   

중앙값은 (0 + 2) / 2 = 1 이므로 1번째 인덱스의 값인 -3이 된다.   
이 값은 -8보다 크기 때문에 배열 내 최댓값은 -8이 된다.   

|<span style="color:red"> 0 </span>| 1 | 2 | 3 | 4 | 5 | 6 | 7 |   
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |   
| **-8**| -3 | 2 | 0 | 5 | 8 | 11 | 15 |

배열의 요소는 1개만 남았으므로 중앙값은 -8, 찾는 값과 일치하므로 종료한다.   

시간복잡도는 배열의 크기가 N이라고 하면, 첫 시행 후에 N / 2, 두 번째 시행 후에 N / 4   
k번째 시행 후에는 (1/2)^k * N 이 된다.   

최악의 경우 배열의 사이즈가 1이 될 때까지 진행 하므로 (1/2)^k*N = 1이고,   
양변에 로그를 취하면 log2N이 된다.

따라서 이진 탐색의 시간 복잡도는 **O(logN)** 이다.   

구현은 **반복문**과 **재귀** 두 가지 방법으로 구현이 가능하다.
### 반복문
```java
    public static int binarySearch(int arr[], int find) {
      int mid;
      int left = 0;
      int right = arr.length - 1;
    
      // 배열의 크기가 1이 될 때까지 반복.
      while (left <= right) {
        mid = (right + left) / 2;
        
        if (arr[mid] == find) {
          return mid;
        }
    
        if (find < arr[mid]) {
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
    
      // 원하는 값을 찾지 못함.
      return -1;
    }
```
### 재귀
```java
public static int binarySearch(int[] arr, int find, int left, int right) {
  // 원하는 값을 찾지 못함.
  if (left > right) {
    return -1;
  }

  int mid = (left + right) / 2;
  
  // 원하는 값을 찾았다면 그 위치를 반환.
  if (find == arr[mid]) {
    return mid;
  }

  if (find > arr[mid]) {
    return binarySearch(arr, find, mid + 1, right);
  }
  return binarySearch(arr, find, left, mid - 1);
}
```

